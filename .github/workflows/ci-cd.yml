name: Deploy RoastMyLanding to EC2

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: roast-landing

jobs:
  build:
    runs-on: ubuntu-latest
    name: Build Docker Image
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
    outputs:
      image-tag: ${{ steps.get-timestamp.outputs.timestamp }}-${{ steps.get-commit-hash.outputs.sha_short }}
      image-uri: ${{ steps.build-image.outputs.image_uri }}
    
    steps:
    - name: Notify Slack - Pipeline Started
      run: |
        curl -X POST -H 'Content-type: application/json' \
        --data '{
          "attachments": [{
            "color": "#36a64f",
            "blocks": [{
              "type": "header",
              "text": {
                "type": "plain_text",
                "text": "RoastMyLanding Deployment Pipeline Started"
              }
            }, {
              "type": "section",
              "fields": [{
                "type": "mrkdwn",
                "text": "*Triggered by:*\n${{ github.actor }}"
              }, {
                "type": "mrkdwn",
                "text": "*Branch:*\n${{ github.ref_name }}"
              }, {
                "type": "mrkdwn",
                "text": "*Pipeline:*\n#${{ github.run_number }}"
              }, {
                "type": "mrkdwn",
                "text": "*Status:*\nBuilding Docker image"
              }]
            }, {
              "type": "actions",
              "elements": [{
                "type": "button",
                "text": {
                  "type": "plain_text",
                  "text": "View Pipeline"
                },
                "url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
              }]
            }]
          }]
        }' \
        ${{ secrets.SLACK_WEBHOOK_URL }}

    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Get commit hash
      id: get-commit-hash
      run: echo "sha_short=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

    - name: Get timestamp
      id: get-timestamp
      run: echo "timestamp=$(date +'%Y%m%d-%H%M%S')" >> $GITHUB_OUTPUT

    - name: Build, tag, and push image to Amazon ECR
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ steps.get-timestamp.outputs.timestamp }}-${{ steps.get-commit-hash.outputs.sha_short }}
      run: |
        # Build a docker container with build args for NEXT_PUBLIC_ variables
        docker build \
          --build-arg NEXT_PUBLIC_SUPABASE_URL="${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}" \
          --build-arg NEXT_PUBLIC_SUPABASE_ANON_KEY="${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}" \
          --build-arg NEXT_PUBLIC_APP_URL="${{ secrets.NEXT_PUBLIC_APP_URL }}" \
          --build-arg NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY="${{ secrets.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY }}" \
          -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        
        # Also tag as latest
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        # Output the full image URI
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "image_uri=$ECR_REGISTRY/$ECR_REPOSITORY" >> $GITHUB_OUTPUT

    - name: Notify Slack - Docker Build Success
      run: |
        curl -X POST -H 'Content-type: application/json' \
        --data '{
          "attachments": [{
            "color": "#36a64f",
            "blocks": [{
              "type": "section",
              "text": {
                "type": "mrkdwn",
                "text": "Docker Image Built Successfully\nImage: `${{ steps.get-timestamp.outputs.timestamp }}-${{ steps.get-commit-hash.outputs.sha_short }}`\nStarting EC2 deployment..."
              }
            }]
          }]
        }' \
        ${{ secrets.SLACK_WEBHOOK_URL }}

    - name: Notify Slack - Starting Deployment
      run: |
        curl -X POST -H 'Content-type: application/json' \
        --data '{"text":"**Starting EC2 Deployment**\nServer: `${{ secrets.EC2_HOST }}`\nImage: `${{ needs.build.outputs.image-tag }}`"}' \
        ${{ secrets.SLACK_WEBHOOK_URL }}

  deploy:
    runs-on: ubuntu-latest
    name: Deploy to EC2
    needs: build
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Copy docker-compose.prod.yml to EC2
      uses: appleboy/scp-action@v0.1.4
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ubuntu
        key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
        port: 22
        source: "docker-compose.prod.yml"
        target: "${{ secrets.EC2_APP_PATH }}/"
        strip_components: 0

    - name: Setup EC2 Environment
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ubuntu
        key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
        port: 22
        script: |
          echo "Setting up application directory..."
          mkdir -p ${{ secrets.EC2_APP_PATH }}/logs
          cd ${{ secrets.EC2_APP_PATH }}
          echo "Application directory ready"

    - name: Generate Environment Configuration
      uses: appleboy/ssh-action@v1.0.3
      env:
        NEXT_PUBLIC_APP_URL: ${{ secrets.NEXT_PUBLIC_APP_URL }}
        NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
        NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}
        SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
        NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY: ${{ secrets.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY }}
        STRIPE_SECRET_KEY: ${{ secrets.STRIPE_SECRET_KEY }}
        STRIPE_WEBHOOK_SECRET: ${{ secrets.STRIPE_WEBHOOK_SECRET }}
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        REDIS_HOST: ${{ secrets.REDIS_HOST }}
        REDIS_PORT: ${{ secrets.REDIS_PORT }}
        REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
        REDIS_DB: ${{ secrets.REDIS_DB }}
        REDIS_URL: ${{ secrets.REDIS_URL }}
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        S3_BUCKET: ${{ secrets.S3_BUCKET }}
        CLOUDFRONT_DOMAIN: ${{ secrets.CLOUDFRONT_DOMAIN }}
        CLOUDFRONT_DISTRIBUTION_ID: ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}
        GOOGLE_OAUTH_CLIENT_ID: ${{ secrets.GOOGLE_OAUTH_CLIENT_ID }}
        GOOGLE_OAUTH_CLIENT_SECRET: ${{ secrets.GOOGLE_OAUTH_CLIENT_SECRET }}
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        NODE_ENV: production
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ubuntu
        key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
        port: 22
        envs: NEXT_PUBLIC_APP_URL,NEXT_PUBLIC_SUPABASE_URL,NEXT_PUBLIC_SUPABASE_ANON_KEY,SUPABASE_SERVICE_ROLE_KEY,NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY,STRIPE_SECRET_KEY,STRIPE_WEBHOOK_SECRET,OPENAI_API_KEY,ANTHROPIC_API_KEY,GEMINI_API_KEY,REDIS_HOST,REDIS_PORT,REDIS_PASSWORD,REDIS_DB,REDIS_URL,AWS_ACCESS_KEY_ID,AWS_SECRET_ACCESS_KEY,S3_BUCKET,CLOUDFRONT_DOMAIN,CLOUDFRONT_DISTRIBUTION_ID,GOOGLE_OAUTH_CLIENT_ID,GOOGLE_OAUTH_CLIENT_SECRET,SLACK_WEBHOOK_URL,NODE_ENV
        script: |
          cd ${{ secrets.EC2_APP_PATH }}
          echo "Generating production .env.roast-landing file..."
          cat > .env.roast-landing << EOF
          # Production Environment Configuration - Generated from GitHub Secrets
          NODE_ENV=${NODE_ENV}
          PORT=3000
          
          # App Configuration
          NEXT_PUBLIC_APP_URL=${NEXT_PUBLIC_APP_URL}
          
          # Supabase Configuration
          NEXT_PUBLIC_SUPABASE_URL=${NEXT_PUBLIC_SUPABASE_URL}
          NEXT_PUBLIC_SUPABASE_ANON_KEY=${NEXT_PUBLIC_SUPABASE_ANON_KEY}
          SUPABASE_SERVICE_ROLE_KEY=${SUPABASE_SERVICE_ROLE_KEY}
          
          # Stripe Configuration
          NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=${NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY}
          STRIPE_SECRET_KEY=${STRIPE_SECRET_KEY}
          STRIPE_WEBHOOK_SECRET=${STRIPE_WEBHOOK_SECRET}
          
          # AI Providers
          OPENAI_API_KEY=${OPENAI_API_KEY}
          ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}
          GEMINI_API_KEY=${GEMINI_API_KEY}
          
          # Redis Configuration (RoastMyLanding uses DB 0)
          REDIS_HOST=${REDIS_HOST}
          REDIS_PORT=${REDIS_PORT}
          REDIS_PASSWORD=${REDIS_PASSWORD}
          REDIS_DB=0
          REDIS_URL=redis://:${REDIS_PASSWORD}@${REDIS_HOST}:${REDIS_PORT}/0
          
          # AWS Configuration
          AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
          AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
          AWS_REGION=us-east-1
          
          # Storage Configuration
          S3_BUCKET=${S3_BUCKET}
          CLOUDFRONT_DOMAIN=${CLOUDFRONT_DOMAIN}
          CLOUDFRONT_DISTRIBUTION_ID=${CLOUDFRONT_DISTRIBUTION_ID}
          
          # Google OAuth Configuration
          GOOGLE_OAUTH_CLIENT_ID=${GOOGLE_OAUTH_CLIENT_ID}
          GOOGLE_OAUTH_CLIENT_SECRET=${GOOGLE_OAUTH_CLIENT_SECRET}
          
          # Notifications
          SLACK_WEBHOOK_URL=${SLACK_WEBHOOK_URL}
          
          # Cache
          CACHE_BACKEND=redis
          EOF
          
          # Create symlink for .env (Docker Compose expects .env)
          ln -sf .env.roast-landing .env
          echo "Environment configuration ready"

    - name: Login to ECR
      uses: appleboy/ssh-action@v1.0.3
      env:
        ECR_REPOSITORY_URI: ${{ needs.build.outputs.image-uri }}
        AWS_DEFAULT_REGION: ${{ env.AWS_REGION }}
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ubuntu
        key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
        port: 22
        envs: ECR_REPOSITORY_URI,AWS_DEFAULT_REGION
        script: |
          cd ${{ secrets.EC2_APP_PATH }}
          echo "Logging into Amazon ECR..."
          aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $ECR_REPOSITORY_URI
          echo "ECR login successful"

    - name: Pull Docker Image
      uses: appleboy/ssh-action@v1.0.3
      env:
        ECR_REPOSITORY_URI: ${{ needs.build.outputs.image-uri }}
        IMAGE_TAG: ${{ needs.build.outputs.image-tag }}
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ubuntu
        key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
        port: 22
        envs: ECR_REPOSITORY_URI,IMAGE_TAG
        script: |
          cd ${{ secrets.EC2_APP_PATH }}
          echo "Pulling Docker image: $ECR_REPOSITORY_URI:$IMAGE_TAG"
          docker pull $ECR_REPOSITORY_URI:$IMAGE_TAG
          echo "Docker image pulled successfully"

    - name: Stop Existing Containers
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ubuntu
        key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
        port: 22
        script: |
          cd ${{ secrets.EC2_APP_PATH }}
          echo "Stopping existing RoastMyLanding containers..."
          docker-compose -f docker-compose.prod.yml down --timeout 30 || echo "No RoastMyLanding containers to stop"
          
          echo "Checking for port conflicts..."
          # Check and warn about port conflicts but don't stop other services
          if docker ps | grep -q ":3000->"; then
            echo "Warning: Port 3000 is in use by another service. RoastMyLanding will use alternative port."
          fi
          echo "Port conflict check completed"

    - name: Start Application
      uses: appleboy/ssh-action@v1.0.3
      env:
        ECR_REPOSITORY_URI: ${{ needs.build.outputs.image-uri }}
        IMAGE_TAG: ${{ needs.build.outputs.image-tag }}
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ubuntu
        key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
        port: 22
        envs: ECR_REPOSITORY_URI,IMAGE_TAG
        script: |
          cd ${{ secrets.EC2_APP_PATH }}
          echo "Starting application containers..."
          echo "Using image: $ECR_REPOSITORY_URI:$IMAGE_TAG"
          
          # Update docker-compose.prod.yml with the specific image tag
          sed -i "s|image: .*|image: $ECR_REPOSITORY_URI:$IMAGE_TAG|g" docker-compose.prod.yml
          
          docker-compose -f docker-compose.prod.yml up -d
          
          # Check if containers actually started
          sleep 5
          RUNNING_CONTAINERS=$(docker-compose -f docker-compose.prod.yml ps --services --filter "status=running" | wc -l)
          if [ "$RUNNING_CONTAINERS" -eq 0 ]; then
            echo "No containers are running! Deployment failed."
            docker-compose -f docker-compose.prod.yml logs
            exit 1
          fi
          echo "Application containers started successfully"

    - name: Cleanup Old Images
      uses: appleboy/ssh-action@v1.0.3
      env:
        ECR_REPOSITORY_URI: ${{ needs.build.outputs.image-uri }}
        IMAGE_TAG: ${{ needs.build.outputs.image-tag }}
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ubuntu
        key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
        port: 22
        envs: ECR_REPOSITORY_URI,IMAGE_TAG
        script: |
          cd ${{ secrets.EC2_APP_PATH }}
          echo "Cleaning up old Docker images..."
          # Keep only the current image and remove others for the same repository
          docker images "$ECR_REPOSITORY_URI" --format "table {{.Repository}}:{{.Tag}}\t{{.ID}}" | tail -n +2 | grep -v "$IMAGE_TAG" | awk '{print $2}' | xargs -r docker rmi || echo "No old images to remove"
          echo "Image cleanup completed"

    - name: Wait for Application Startup
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ubuntu
        key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
        port: 22
        script: |
          cd ${{ secrets.EC2_APP_PATH }}
          echo "Waiting for application to start up..."
          sleep 30
          echo "Checking container status..."
          docker-compose -f docker-compose.prod.yml ps
          
          # Verify containers are actually healthy
          UNHEALTHY_CONTAINERS=$(docker-compose -f docker-compose.prod.yml ps --filter "status=running" | grep -c "unhealthy\|starting" || echo "0")
          if [ "$UNHEALTHY_CONTAINERS" -gt 0 ]; then
            echo "Some containers are not healthy yet"
            docker-compose -f docker-compose.prod.yml logs --tail=20
          fi

    - name: Notify Slack - Deployment Progress
      run: |
        curl -X POST -H 'Content-type: application/json' \
        --data '{"text":"**Deployment Progress**\nContainers started, performing health checks..."}' \
        "${{ secrets.SLACK_WEBHOOK_URL }}"

    - name: Verify deployment
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ubuntu
        key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
        port: 22
        script: |
          echo "Verifying deployment..."
          cd ${{ secrets.EC2_APP_PATH }}
          
          # Check if containers are running
          docker-compose -f docker-compose.prod.yml ps
          
          # Test health endpoint
          HEALTH_STATUS=0
          for i in {1..5}; do
            if curl -f http://localhost:3000/api/health; then
              echo "Application is healthy!"
              HEALTH_STATUS=1
              break
            else
              echo "Attempt $i/5: Application not ready yet, waiting..."
              sleep 10
            fi
          done
          
          if [ $HEALTH_STATUS -eq 0 ]; then
            echo "Health check failed - deployment failed"
            exit 1
          fi
          
          # Show recent logs
          echo "Recent application logs:"
          docker-compose -f docker-compose.prod.yml logs --tail=20 app

    - name: Notify Slack - Deployment Result
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          curl -X POST -H 'Content-type: application/json' \
          --data '{
            "attachments": [{
              "color": "#36a64f",
              "blocks": [{
                "type": "header",
                "text": {
                  "type": "plain_text",
                  "text": "RoastMyLanding Deployment Successful"
                }
              }, {
                "type": "section",
                "fields": [{
                  "type": "mrkdwn",
                  "text": "*Environment:*\nProduction"
                }, {
                  "type": "mrkdwn",
                  "text": "*Image:*\n`${{ needs.build.outputs.image-tag }}`"
                }, {
                  "type": "mrkdwn",
                  "text": "*Port:*\n3000"
                }, {
                  "type": "mrkdwn",
                  "text": "*Pipeline:*\n#${{ github.run_number }}"
                }]
              }, {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*Live URL:*\n<https://tanta.com.ng|RoastMyLanding Production Site>"
                }
              }, {
                "type": "actions",
                "elements": [{
                  "type": "button",
                  "text": {
                    "type": "plain_text",
                    "text": "Visit Site"
                  },
                  "url": "https://tanta.com.ng"
                }, {
                  "type": "button",
                  "text": {
                    "type": "plain_text",
                    "text": "Health Check"
                  },
                  "url": "https://tanta.com.ng/api/health"
                }]
              }]
            }]
          }' \
          "${{ secrets.SLACK_WEBHOOK_URL }}"
        else
          curl -X POST -H 'Content-type: application/json' \
          --data '{
            "attachments": [{
              "color": "#ff0000",
              "blocks": [{
                "type": "header",
                "text": {
                  "type": "plain_text",
                  "text": "RoastMyLanding Deployment Failed"
                }
              }, {
                "type": "section",
                "fields": [{
                  "type": "mrkdwn",
                  "text": "*Pipeline:*\n#${{ github.run_number }}"
                }, {
                  "type": "mrkdwn",
                  "text": "*Branch:*\n${{ github.ref_name }}"
                }, {
                  "type": "mrkdwn",
                  "text": "*Triggered by:*\n${{ github.actor }}"
                }, {
                  "type": "mrkdwn",
                  "text": "*Status:*\nFAILED"
                }]
              }, {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "RoastMyLanding services need immediate attention!"
                }
              }, {
                "type": "actions",
                "elements": [{
                  "type": "button",
                  "text": {
                    "type": "plain_text",
                    "text": "View Failed Pipeline"
                  },
                  "url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                }]
              }]
            }]
          }' \
          "${{ secrets.SLACK_WEBHOOK_URL }}"
        fi
      if: always()
