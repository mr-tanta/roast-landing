name: RoastMyLanding CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      skip_tests:
        description: 'Skip tests'
        required: false
        default: false
        type: boolean

env:
  NODE_VERSION: '20'
  AWS_REGION: 'us-east-1'
  PROJECT_NAME: 'roastmylanding'
  SLACK_CHANNEL: '#deployments'

jobs:
  # Pre-flight checks and setup
  setup:
    name: Setup and Validation
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env-setup.outputs.environment }}
      should-deploy: ${{ steps.env-setup.outputs.should-deploy }}
      lambda-changed: ${{ steps.changes.outputs.lambda }}
      frontend-changed: ${{ steps.changes.outputs.frontend }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect changes
        uses: dorny/paths-filter@v2
        id: changes
        with:
          filters: |
            lambda:
              - 'lambda/**'
              - 'terraform/**'
            frontend:
              - 'src/**'
              - 'public/**'
              - 'package*.json'
              - 'next.config.ts'
              - 'tailwind.config.ts'
              - '.env*'

      - name: Environment setup
        id: env-setup
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          else
            echo "environment=none" >> $GITHUB_OUTPUT
            echo "should-deploy=false" >> $GITHUB_OUTPUT
          fi

      - name: Job summary
        run: |
          echo "## Deployment Plan" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** ${{ steps.env-setup.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Should Deploy:** ${{ steps.env-setup.outputs.should-deploy }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Lambda Changed:** ${{ steps.changes.outputs.lambda }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Frontend Changed:** ${{ steps.changes.outputs.frontend }}" >> $GITHUB_STEP_SUMMARY

      - name: Notify Slack - Pipeline Start
        if: steps.env-setup.outputs.should-deploy == 'true'
        uses: 8398a7/action-slack@v3
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        with:
          status: custom
          channel: '#deployments'
          custom_payload: |
            {
              "text": "RoastMyLanding Deployment Pipeline Started",
              "attachments": [
                {
                  "color": "#36a64f",
                  "fields": [
                    {
                      "title": "Repository",
                      "value": "${{ github.repository }}",
                      "short": true
                    },
                    {
                      "title": "Environment",
                      "value": "${{ steps.env-setup.outputs.environment }}",
                      "short": true
                    },
                    {
                      "title": "Commit",
                      "value": "`${{ github.sha }}`.substring(0, 7)",
                      "short": true
                    },
                    {
                      "title": "Author",
                      "value": "${{ github.actor }}",
                      "short": true
                    },
                    {
                      "title": "Changes",
                      "value": "Frontend: ${{ steps.changes.outputs.frontend == 'true' && 'Yes' || 'No' }} | Lambda: ${{ steps.changes.outputs.lambda == 'true' && 'Yes' || 'No' }}",
                      "short": false
                    }
                  ]
                }
              ]
            }

  # Security and compliance checks
  security:
    name: Security and Compliance
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run secret scan
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          extra_args: --debug --only-verified

      - name: SAST Scan
        uses: github/super-linter@v4
        env:
          DEFAULT_BRANCH: main
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VALIDATE_ALL_CODEBASE: false
          VALIDATE_TYPESCRIPT_ES: true
          VALIDATE_JAVASCRIPT_ES: true
          VALIDATE_JSON: true
          VALIDATE_YAML: true
          VALIDATE_BASH: true
          VALIDATE_DOCKERFILE: true
          VALIDATE_TERRAFORM_TERRASCAN: true

  # Frontend build and test
  frontend:
    name: Frontend Build and Test
    runs-on: ubuntu-latest
    needs: [setup, security]
    if: needs.setup.outputs.frontend-changed == 'true' || github.event.inputs.skip_tests != 'true'
    strategy:
      matrix:
        node-version: [20]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'pnpm'

      - name: Install dependencies
        run: |
          pnpm install --no-frozen-lockfile
          pnpm list --depth=0

      - name: Lint code
        run: pnpm run lint

      - name: Test Redis connectivity
        env:
          REDIS_HOST: ${{ secrets.REDIS_HOST }}
          REDIS_PORT: ${{ secrets.REDIS_PORT }}
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          REDIS_DB: ${{ secrets.REDIS_DB }}
          REDIS_URL: ${{ secrets.REDIS_URL }}
        run: pnpm test:redis

      - name: Build frontend
        env:
          NODE_ENV: production
          NEXT_PUBLIC_APP_URL: ${{ secrets.NEXT_PUBLIC_APP_URL }}
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY: ${{ secrets.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY }}
          STRIPE_SECRET_KEY: ${{ secrets.STRIPE_SECRET_KEY }}
          STRIPE_WEBHOOK_SECRET: ${{ secrets.STRIPE_WEBHOOK_SECRET }}
          STRIPE_PRICE_ID_PRO: ${{ secrets.STRIPE_PRICE_ID_PRO }}
          NEXT_PUBLIC_APP_URL: ${{ secrets.NEXT_PUBLIC_APP_URL }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          REDIS_HOST: ${{ secrets.REDIS_HOST }}
          REDIS_PORT: ${{ secrets.REDIS_PORT }}
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          REDIS_DB: ${{ secrets.REDIS_DB }}
          REDIS_URL: ${{ secrets.REDIS_URL }}
        run: |
          pnpm run build:prod
          ls -la .next/

      - name: Bundle analysis
        run: |
          du -sh .next/
          du -sh .next/static/ || echo "No static dir"
          echo "## Build Results" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Size:** $(du -sh .next/ | cut -f1)" >> $GITHUB_STEP_SUMMARY
          echo "- **Static Assets:** $(du -sh .next/static/ 2>/dev/null | cut -f1 || echo 'N/A')" >> $GITHUB_STEP_SUMMARY

      - name: Run frontend tests
        if: github.event.inputs.skip_tests != 'true'
        run: |
          # Add your frontend tests here when available
          echo "Frontend tests placeholder - add Jest/Cypress tests"

      - name: Upload build artifacts
        if: matrix.node-version == 20
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build
          path: |
            .next/
            public/
            package*.json
            next.config.ts
          retention-days: 7

  # Lambda/Backend build and test
  lambda:
    name: Lambda Build and Test
    runs-on: ubuntu-latest
    needs: [setup, security]
    if: needs.setup.outputs.lambda-changed == 'true' && false
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'
          cache-dependency-path: lambda/pnpm-lock.yaml

      - name: Install Lambda dependencies
        run: |
          cd lambda
          pnpm install --frozen-lockfile --prod --prefer-offline
          pnpm list --depth=0

      - name: Validate Lambda function
        run: |
          cd lambda
          node -e "const handler = require('./roast-handler'); console.log('Lambda function loaded successfully');"

      - name: Package Lambda
        run: |
          cd lambda
          zip -r ../lambda-deployment.zip . -x "*.sh" "deploy-*.sh"
          ls -lh ../lambda-deployment.zip

      - name: Upload Lambda artifact
        uses: actions/upload-artifact@v4
        with:
          name: lambda-deployment
          path: lambda-deployment.zip
          retention-days: 7

  # Infrastructure validation
  infrastructure:
    name: Infrastructure Validation
    runs-on: ubuntu-latest
    needs: [setup, security]
    if: needs.setup.outputs.lambda-changed == 'true' && false
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ðŸ”§ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ~1.0

      - name: ðŸ” Terraform Format Check
        run: |
          cd terraform
          terraform fmt -check -diff

      - name: âœ… Terraform Validate
        run: |
          cd terraform
          terraform init -backend=false
          terraform validate

      - name: ðŸ“‹ Terraform Plan (Dry Run)
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          cd terraform
          terraform init
          terraform plan -no-color > ../terraform-plan.txt 2>&1 || true
          
          echo "## ðŸ—ï¸ Infrastructure Plan" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          head -50 ../terraform-plan.txt >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

  # Integration testing
  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: [setup, security]
    if: github.event.inputs.skip_tests != 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Test Production API
        run: |
          echo "Testing production API endpoint..."
          PROD_URL="https://tanta.com.ng"
          
          # Health check
          HEALTH_STATUS=$(curl -s -w "%{http_code}" -o /dev/null "$PROD_URL/api/health" || echo "000")
          echo "Health check status: $HEALTH_STATUS"
          
          # Basic connectivity test
          FRONTEND_STATUS=$(curl -s -w "%{http_code}" -o /dev/null "$PROD_URL" || echo "000")
          echo "Frontend status: $FRONTEND_STATUS"
          
          if [[ "$HEALTH_STATUS" == "200" ]] && [[ "$FRONTEND_STATUS" == "200" ]]; then
            echo "Production site responding correctly"
          else
            echo "Production site not fully available yet (Health: $HEALTH_STATUS, Frontend: $FRONTEND_STATUS)"
            echo "This may be expected if this is the first deployment"
          fi

      - name: API Performance Test
        run: |
          echo "Running performance tests..."
          PROD_URL="https://tanta.com.ng"
          
          # Simple load test on health endpoint
          for i in {1..5}; do
            START_TIME=$(date +%s%3N)
            curl -s "$PROD_URL/api/health" > /dev/null
            END_TIME=$(date +%s%3N)
            DURATION=$((END_TIME - START_TIME))
            echo "Health check $i: ${DURATION}ms"
          done

  # Deployment to staging
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [frontend, integration-tests]
    if: false
    environment:
      name: staging
      url: https://staging.roastmylanding.com
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ðŸ“¥ Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: lambda-deployment
          path: ./

      - name: âš¡ Deploy Lambda
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          aws lambda update-function-code \
            --function-name roastmylanding-roast-handler \
            --zip-file fileb://lambda-deployment.zip \
            --region ${{ env.AWS_REGION }}
          
          echo "âœ… Lambda deployed to staging"

      - name: ðŸ§ª Staging smoke tests
        run: |
          echo "Running staging smoke tests..."
          # Add staging-specific tests here
          sleep 10  # Wait for Lambda to be ready
          
          API_URL="https://1il9nnkz4b.execute-api.us-east-1.amazonaws.com/prod"
          RESPONSE=$(curl -s -X POST "$API_URL/roast" \
            -H "Content-Type: application/json" \
            -d '{"url": "https://staging-test.example.com"}')
          
          if echo "$RESPONSE" | grep -q "roast"; then
            echo "âœ… Staging deployment successful"
          else
            echo "âŒ Staging smoke test failed"
            exit 1
          fi

      - name: ðŸ“¢ Notify Slack - Staging
        if: always()
        uses: 8398a7/action-slack@v3
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        with:
          status: ${{ job.status }}
          channel: '#deployments'
          fields: repo,message,commit,author,action,eventName,ref,workflow
          custom_payload: |
            {
              "text": "ðŸš€ Staging Deployment ${{ job.status }}",
              "attachments": [
                {
                  "color": "${{ job.status }}" === "success" ? "good" : "danger",
                  "fields": [
                    {
                      "title": "Repository",
                      "value": "${{ github.repository }}",
                      "short": true
                    },
                    {
                      "title": "Environment",
                      "value": "Staging",
                      "short": true
                    },
                    {
                      "title": "Commit",
                      "value": "${{ github.sha }}".substring(0, 7),
                      "short": true
                    },
                    {
                      "title": "Author",
                      "value": "${{ github.actor }}",
                      "short": true
                    }
                  ]
                }
              ]
            }

  # Production deployment (Docker/EC2)
  deploy-production:
    name: Deploy to Production (Docker/EC2)
    runs-on: ubuntu-latest
    needs: [frontend, integration-tests]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment:
      name: production
      url: https://tanta.com.ng
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push Docker image
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: roast-landing
          IMAGE_TAG: ${{ github.sha }}
        run: |
          # Build the Docker image
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .
          
          # Push images to ECR
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Deploy to EC2
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_SSH_PRIVATE_KEY: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
          APP_PATH: ${{ secrets.EC2_APP_PATH }}
          ECR_REPOSITORY: roast-landing
        run: |
          # Create SSH key file
          echo "$EC2_SSH_PRIVATE_KEY" > private_key.pem
          chmod 600 private_key.pem
          
          # Create deployment script
          cat > deploy_script.sh << 'EOF'
          #!/bin/bash
          set -e
          
          # Navigate to app directory
          cd $APP_PATH
          
          # Login to ECR
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin $ECR_REGISTRY
          
          # Pull latest image
          docker pull $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          
          # Create environment file with all secrets
          cat > .env.production << 'ENVEOF'
          # App Configuration
          NEXT_PUBLIC_APP_URL=https://tanta.com.ng
          NODE_ENV=production
          
          # Supabase Configuration
          NEXT_PUBLIC_SUPABASE_URL=${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY=${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}
          SUPABASE_SERVICE_ROLE_KEY=${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          
          # Redis Configuration
          REDIS_HOST=${{ secrets.REDIS_HOST }}
          REDIS_PORT=${{ secrets.REDIS_PORT }}
          REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
          REDIS_DB=${{ secrets.REDIS_DB }}
          REDIS_URL=${{ secrets.REDIS_URL }}
          
          # AI Providers
          OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
          ANTHROPIC_API_KEY=${{ secrets.ANTHROPIC_API_KEY }}
          GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }}
          
          # Stripe
          NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=${{ secrets.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY }}
          STRIPE_SECRET_KEY=${{ secrets.STRIPE_SECRET_KEY }}
          STRIPE_WEBHOOK_SECRET=${{ secrets.STRIPE_WEBHOOK_SECRET }}
          
          # AWS
          AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION=us-east-1
          
          # Storage
          S3_BUCKET=${{ secrets.S3_BUCKET }}
          CLOUDFRONT_DOMAIN=${{ secrets.CLOUDFRONT_DOMAIN }}
          CLOUDFRONT_DISTRIBUTION_ID=${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}
          
          # Google OAuth
          GOOGLE_OAUTH_CLIENT_ID=${{ secrets.GOOGLE_OAUTH_CLIENT_ID }}
          GOOGLE_OAUTH_CLIENT_SECRET=${{ secrets.GOOGLE_OAUTH_CLIENT_SECRET }}
          
          # Notifications
          SLACK_WEBHOOK_URL=${{ secrets.SLACK_WEBHOOK_URL }}
          
          # Cache
          CACHE_BACKEND=redis
          ENVEOF
          
          # Create docker-compose.prod.yml
          cat > docker-compose.prod.yml << 'COMPOSEEOF'
          version: '3.8'
          
          services:
            app:
              image: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
              container_name: roast-landing-app
              restart: unless-stopped
              ports:
                - "3000:3000"
              env_file:
                - .env.production
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:3000/api/health"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 40s
              logging:
                driver: "json-file"
                options:
                  max-size: "10m"
                  max-file: "3"
          COMPOSEEOF
          
          # Stop existing containers
          docker-compose -f docker-compose.prod.yml down || true
          
          # Start new containers
          docker-compose -f docker-compose.prod.yml up -d
          
          # Wait for health check
          echo "Waiting for application to be healthy..."
          sleep 30
          
          # Health check
          if curl -f http://localhost:3000/api/health; then
            echo "Application deployment successful!"
          else
            echo "Application health check failed!"
            docker-compose -f docker-compose.prod.yml logs
            exit 1
          fi
          
          # Cleanup old images (keep last 3)
          docker images $ECR_REGISTRY/$ECR_REPOSITORY --format "table {{.Tag}}\t{{.ID}}" | grep -v TAG | tail -n +4 | awk '{print $2}' | xargs -r docker rmi || true
          
          EOF
          
          # Copy and execute deployment script on EC2
          scp -i private_key.pem -o StrictHostKeyChecking=no deploy_script.sh ubuntu@$EC2_HOST:/tmp/
          ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@$EC2_HOST "
            export ECR_REGISTRY=$ECR_REGISTRY
            export ECR_REPOSITORY=$ECR_REPOSITORY
            export IMAGE_TAG=$IMAGE_TAG
            export APP_PATH=$APP_PATH
            chmod +x /tmp/deploy_script.sh
            /tmp/deploy_script.sh
          "

      - name: Production smoke tests
        run: |
          echo "Running production smoke tests..."
          sleep 10  # Brief wait after deployment
          
          PROD_URL="https://tanta.com.ng"
          
          # Health check test
          HEALTH_STATUS=$(curl -s -w "%{http_code}" -o /dev/null "$PROD_URL/api/health" || echo "000")
          echo "Health check status: $HEALTH_STATUS"
          
          # Frontend availability test
          FRONTEND_STATUS=$(curl -s -w "%{http_code}" -o /dev/null "$PROD_URL" || echo "000")
          echo "Frontend status: $FRONTEND_STATUS"
          
          if [[ "$HEALTH_STATUS" == "200" ]] && [[ "$FRONTEND_STATUS" == "200" ]]; then
            echo "Production deployment successful"
            echo "## Production Deployment Success" >> $GITHUB_STEP_SUMMARY
            echo "- Frontend responding correctly" >> $GITHUB_STEP_SUMMARY
            echo "- Health endpoint accessible" >> $GITHUB_STEP_SUMMARY
            echo "- All smoke tests passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "Production smoke test failed"
            echo "Health Status: $HEALTH_STATUS, Frontend Status: $FRONTEND_STATUS"
            exit 1
          fi

      - name: Post-deployment metrics
        run: |
          echo "Collecting post-deployment metrics..."
          PROD_URL="https://tanta.com.ng"
          
          # Response time test
          START_TIME=$(date +%s%3N)
          curl -s "$PROD_URL" > /dev/null
          END_TIME=$(date +%s%3N)
          RESPONSE_TIME=$((END_TIME - START_TIME))
          
          echo "## Performance Metrics" >> $GITHUB_STEP_SUMMARY
          echo "- **Frontend Response Time:** ${RESPONSE_TIME}ms" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployment Time:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> $GITHUB_STEP_SUMMARY
          echo "- **Production URL:** $PROD_URL" >> $GITHUB_STEP_SUMMARY

      - name: Notify Slack - Production
        if: always()
        uses: 8398a7/action-slack@v3
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        with:
          status: ${{ job.status }}
          channel: '#deployments'
          fields: repo,message,commit,author,action,eventName,ref,workflow
          custom_payload: |
            {
              "text": "${{ job.status }}" === "success" ? "Roast Landing Production Deployment Successful!" : "Roast Landing Production Deployment Failed!",
              "attachments": [
                {
                  "color": "${{ job.status }}" === "success" ? "good" : "danger",
                  "fields": [
                    {
                      "title": "Repository",
                      "value": "${{ github.repository }}",
                      "short": true
                    },
                    {
                      "title": "Environment",
                      "value": "Production (Docker/EC2)",
                      "short": true
                    },
                    {
                      "title": "Commit",
                      "value": "${{ github.sha }}".substring(0, 7),
                      "short": true
                    },
                    {
                      "title": "Author",
                      "value": "${{ github.actor }}",
                      "short": true
                    },
                    {
                      "title": "Live URL",
                      "value": "https://tanta.com.ng",
                      "short": false
                    }
                  ]
                }
              ]
            }

  # Failure notification job
  notify-failure:
    name: Failure Notification
    runs-on: ubuntu-latest
    needs: [setup, security, frontend, integration-tests]
    if: always() && (contains(needs.*.result, 'failure') || contains(needs.*.result, 'cancelled'))
    steps:
      - name: Notify Slack - Pipeline Failure
        uses: 8398a7/action-slack@v3
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        with:
          status: failure
          channel: '#deployments'
          custom_payload: |
            {
              "text": "RoastMyLanding Pipeline FAILED",
              "attachments": [
                {
                  "color": "danger",
                  "fields": [
                    {
                      "title": "Repository",
                      "value": "${{ github.repository }}",
                      "short": true
                    },
                    {
                      "title": "Commit",
                      "value": "${{ github.sha }}".substring(0, 7),
                      "short": true
                    },
                    {
                      "title": "Author",
                      "value": "${{ github.actor }}",
                      "short": true
                    },
                    {
                      "title": "Branch",
                      "value": "${{ github.ref_name }}",
                      "short": true
                    },
                    {
                      "title": "Failed Jobs",
                      "value": "Setup: ${{ needs.setup.result }}, Security: ${{ needs.security.result }}, Frontend: ${{ needs.frontend.result }}, Lambda: ${{ needs.lambda.result }}, Infrastructure: ${{ needs.infrastructure.result }}, Tests: ${{ needs.integration-tests.result }}, Staging: ${{ needs.deploy-staging.result }}, Production: ${{ needs.deploy-production.result }}",
                      "short": false
                    },
                    {
                      "title": "Action",
                      "value": "<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Logs>",
                      "short": false
                    }
                  ]
                }
              ]
            }

  # Cleanup and notifications
  cleanup:
    name: Cleanup and Notifications
    runs-on: ubuntu-latest
    needs: [setup, security, frontend, integration-tests]
    if: always()
    steps:
      - name: Cleanup artifacts
        run: |
          echo "Cleaning up temporary artifacts..."
          # Add any cleanup steps here

      - name: Deployment summary
        run: |
          PIPELINE_STATUS="success"
          if [[ "${{ contains(needs.*.result, 'failure') }}" == "true" ]]; then
            PIPELINE_STATUS="failure"
          elif [[ "${{ contains(needs.*.result, 'cancelled') }}" == "true" ]]; then
            PIPELINE_STATUS="cancelled"
          fi
          
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Pipeline Status:** $PIPELINE_STATUS" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** ${{ needs.setup.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Author:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Timestamp:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> $GITHUB_STEP_SUMMARY
          
          # Job status breakdown
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Job Results:" >> $GITHUB_STEP_SUMMARY
          echo "- Setup: ${{ needs.setup.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- Security: ${{ needs.security.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- Frontend: ${{ needs.frontend.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- Integration Tests: ${{ needs.integration-tests.result }}" >> $GITHUB_STEP_SUMMARY

      - name: Notify Slack - Pipeline Success
        if: "!contains(needs.*.result, 'failure') && !contains(needs.*.result, 'cancelled')"
        uses: 8398a7/action-slack@v3
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        with:
          status: success
          channel: '#deployments'
          custom_payload: |
            {
              "text": "RoastMyLanding Pipeline Completed Successfully!",
              "attachments": [
                {
                  "color": "good",
                  "fields": [
                    {
                      "title": "Repository",
                      "value": "${{ github.repository }}",
                      "short": true
                    },
                    {
                      "title": "Environment",
                      "value": "${{ needs.setup.outputs.environment }}",
                      "short": true
                    },
                    {
                      "title": "Commit",
                      "value": "${{ github.sha }}".substring(0, 7),
                      "short": true
                    },
                    {
                      "title": "Author",
                      "value": "${{ github.actor }}",
                      "short": true
                    },
                    {
                      "title": "Duration",
                      "value": "Completed at $(date -u +"%H:%M:%S UTC")",
                      "short": true
                    },
                    {
                      "title": "Live URL",
                      "value": "https://tanta.com.ng",
                      "short": true
                    }
                  ]
                }
              ]
            }
