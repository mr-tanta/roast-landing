name: Deploy to AWS

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
    types: [opened, synchronize, reopened, closed]

env:
  AWS_REGION: us-east-1
  TERRAFORM_VERSION: 1.6.0
  NODE_VERSION: 20

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Run type checking
        run: npm run type-check
        
      - name: Run tests
        run: npm test
        
      - name: Run linting
        run: npm run lint
        
      - name: Build application
        run: npm run build
        
      - name: Security audit
        run: npm audit --audit-level=high
        
      - name: SonarCloud Scan
        uses: SonarSource/sonarcloud-github-action@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'pull_request'
    outputs:
      plan-changed: ${{ steps.plan.outputs.changed }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false
          
      - name: Terraform Init
        working-directory: terraform
        run: terraform init
        
      - name: Terraform Validate
        working-directory: terraform
        run: terraform validate
        
      - name: Terraform Plan
        id: plan
        working-directory: terraform
        run: |
          terraform plan -out=tfplan -no-color
          echo "changed=$(terraform show -json tfplan | jq '.resource_changes | length > 0')" >> $GITHUB_OUTPUT
          
      - name: Save Terraform Plan
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan
          path: terraform/tfplan
          retention-days: 1

  terraform-apply:
    name: Terraform Apply
    runs-on: ubuntu-latest
    needs: test
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false
          
      - name: Terraform Init
        working-directory: terraform
        run: terraform init
        
      - name: Terraform Apply
        working-directory: terraform
        run: terraform apply -auto-approve

  build-lambda:
    name: Build Lambda Functions
    runs-on: ubuntu-latest
    needs: [test, terraform-apply]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Build Lambda functions
        run: |
          # Build roast handler
          mkdir -p dist/lambda/roast-handler
          cp -r aws/lambda/roast-handler/* dist/lambda/roast-handler/
          cd dist/lambda/roast-handler
          npm init -y
          npm install @supabase/supabase-js aws-sdk ioredis openai @anthropic-ai/sdk @google/generative-ai
          cd ../../../
          
          # Create deployment packages
          cd dist/lambda/roast-handler
          zip -r ../roast-handler.zip .
          cd ../../../
          
      - name: Upload Lambda artifacts
        uses: actions/upload-artifact@v4
        with:
          name: lambda-functions
          path: dist/lambda/*.zip
          retention-days: 7

  deploy-lambda:
    name: Deploy Lambda Functions
    runs-on: ubuntu-latest
    needs: [terraform-apply, build-lambda]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Download Lambda artifacts
        uses: actions/download-artifact@v4
        with:
          name: lambda-functions
          path: dist/lambda/
          
      - name: Create Lambda function (if not exists)
        run: |
          # Check if function exists
          if ! aws lambda get-function --function-name roastmylanding-roast-handler 2>/dev/null; then
            echo "Creating Lambda function..."
            aws lambda create-function \
              --function-name roastmylanding-roast-handler \
              --runtime nodejs20.x \
              --role arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/lambda-execution-role \
              --handler index.handler \
              --zip-file fileb://dist/lambda/roast-handler.zip \
              --timeout 30 \
              --memory-size 1024 \
              --environment Variables='{\"SUPABASE_URL\":\"${{ secrets.SUPABASE_URL }}\",\"SUPABASE_SERVICE_ROLE_KEY\":\"${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}\",\"REDIS_URL\":\"${{ secrets.REDIS_URL }}\",\"SQS_QUEUE_URL\":\"${{ secrets.SQS_QUEUE_URL }}\",\"S3_BUCKET\":\"${{ secrets.S3_BUCKET }}\",\"OPENAI_API_KEY\":\"${{ secrets.OPENAI_API_KEY }}\",\"ANTHROPIC_API_KEY\":\"${{ secrets.ANTHROPIC_API_KEY }}\",\"GEMINI_API_KEY\":\"${{ secrets.GEMINI_API_KEY }}\"}'
          else
            echo "Updating existing Lambda function..."
            aws lambda update-function-code \
              --function-name roastmylanding-roast-handler \
              --zip-file fileb://dist/lambda/roast-handler.zip
              
            aws lambda update-function-configuration \
              --function-name roastmylanding-roast-handler \
              --environment Variables='{\"SUPABASE_URL\":\"${{ secrets.SUPABASE_URL }}\",\"SUPABASE_SERVICE_ROLE_KEY\":\"${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}\",\"REDIS_URL\":\"${{ secrets.REDIS_URL }}\",\"SQS_QUEUE_URL\":\"${{ secrets.SQS_QUEUE_URL }}\",\"S3_BUCKET\":\"${{ secrets.S3_BUCKET }}\",\"OPENAI_API_KEY\":\"${{ secrets.OPENAI_API_KEY }}\",\"ANTHROPIC_API_KEY\":\"${{ secrets.ANTHROPIC_API_KEY }}\",\"GEMINI_API_KEY\":\"${{ secrets.GEMINI_API_KEY }}\"}'
          fi
          
      - name: Create API Gateway (if not exists)
        run: |
          # Check if API Gateway exists
          API_ID=$(aws apigateway get-rest-apis --query "items[?name=='roastmylanding-api'].id" --output text)
          
          if [ "$API_ID" = "" ] || [ "$API_ID" = "None" ]; then
            echo "Creating API Gateway..."
            API_ID=$(aws apigateway create-rest-api --name roastmylanding-api --query 'id' --output text)
            
            # Get root resource
            ROOT_ID=$(aws apigateway get-resources --rest-api-id $API_ID --query 'items[0].id' --output text)
            
            # Create roast resource
            ROAST_RESOURCE_ID=$(aws apigateway create-resource \
              --rest-api-id $API_ID \
              --parent-id $ROOT_ID \
              --path-part roast \
              --query 'id' --output text)
            
            # Create methods
            for METHOD in GET POST OPTIONS; do
              aws apigateway put-method \
                --rest-api-id $API_ID \
                --resource-id $ROAST_RESOURCE_ID \
                --http-method $METHOD \
                --authorization-type NONE
                
              aws apigateway put-integration \
                --rest-api-id $API_ID \
                --resource-id $ROAST_RESOURCE_ID \
                --http-method $METHOD \
                --type AWS_PROXY \
                --integration-http-method POST \
                --uri arn:aws:apigateway:${{ env.AWS_REGION }}:lambda:path/2015-03-31/functions/arn:aws:lambda:${{ env.AWS_REGION }}:${{ secrets.AWS_ACCOUNT_ID }}:function:roastmylanding-roast-handler/invocations
            done
            
            # Deploy API
            aws apigateway create-deployment \
              --rest-api-id $API_ID \
              --stage-name prod
              
            # Add Lambda permission
            aws lambda add-permission \
              --function-name roastmylanding-roast-handler \
              --statement-id apigateway-invoke \
              --action lambda:InvokeFunction \
              --principal apigateway.amazonaws.com \
              --source-arn "arn:aws:execute-api:${{ env.AWS_REGION }}:${{ secrets.AWS_ACCOUNT_ID }}:$API_ID/*/*"
          fi

  deploy-ec2:
    name: Deploy Screenshot Service to EC2
    runs-on: ubuntu-latest
    needs: [terraform-apply]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Create EC2 Launch Template
        run: |
          # User data script for EC2 instance
          cat > user-data.sh << 'EOF'
          #!/bin/bash
          yum update -y
          yum install -y docker git
          
          # Start Docker
          service docker start
          usermod -a -G docker ec2-user
          
          # Install Node.js
          curl -fsSL https://rpm.nodesource.com/setup_20.x | bash -
          yum install -y nodejs
          
          # Install PM2
          npm install -g pm2
          
          # Clone repository
          cd /home/ec2-user
          git clone https://github.com/${{ github.repository }}.git app
          cd app
          
          # Install dependencies for screenshot service
          cd aws/ec2/screenshot-service
          npm install
          
          # Install Playwright
          npx playwright install chromium
          npx playwright install-deps
          
          # Start service with PM2
          pm2 start server.ts --name screenshot-service --interpreter=./node_modules/.bin/tsx
          pm2 startup
          pm2 save
          
          # Setup log rotation
          echo "/var/log/screenshot-service.log {
            daily
            missingok
            rotate 7
            compress
            notifempty
          }" > /etc/logrotate.d/screenshot-service
          EOF
          
          # Create launch template
          TEMPLATE_ID=$(aws ec2 describe-launch-templates --launch-template-names roastmylanding-screenshot-service --query 'LaunchTemplates[0].LaunchTemplateId' --output text 2>/dev/null || echo "")
          
          if [ "$TEMPLATE_ID" = "" ] || [ "$TEMPLATE_ID" = "None" ]; then
            echo "Creating launch template..."
            aws ec2 create-launch-template \
              --launch-template-name roastmylanding-screenshot-service \
              --launch-template-data '{
                "ImageId": "ami-0c02fb55956c7d316",
                "InstanceType": "t3.medium", 
                "SecurityGroupIds": ["${{ secrets.EC2_SECURITY_GROUP_ID }}"],
                "IamInstanceProfile": {"Name": "EC2-Screenshot-Service-Profile"},
                "UserData": "'$(base64 -w 0 user-data.sh)'",
                "TagSpecifications": [{
                  "ResourceType": "instance",
                  "Tags": [{"Key": "Name", "Value": "roastmylanding-screenshot-service"}]
                }]
              }'
          else
            echo "Updating launch template..."
            aws ec2 create-launch-template-version \
              --launch-template-id $TEMPLATE_ID \
              --launch-template-data '{
                "ImageId": "ami-0c02fb55956c7d316",
                "InstanceType": "t3.medium",
                "SecurityGroupIds": ["${{ secrets.EC2_SECURITY_GROUP_ID }}"],
                "IamInstanceProfile": {"Name": "EC2-Screenshot-Service-Profile"},
                "UserData": "'$(base64 -w 0 user-data.sh)'",
                "TagSpecifications": [{
                  "ResourceType": "instance", 
                  "Tags": [{"Key": "Name", "Value": "roastmylanding-screenshot-service"}]
                }]
              }'
          fi

  deploy-frontend:
    name: Deploy Frontend to S3/CloudFront
    runs-on: ubuntu-latest
    needs: [terraform-apply, deploy-lambda]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Install dependencies
        run: npm ci
        
      - name: Build frontend
        run: npm run build
        env:
          NEXT_PUBLIC_API_URL: ${{ secrets.API_GATEWAY_URL }}
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY }}
          
      - name: Create S3 bucket for frontend (if not exists)
        run: |
          BUCKET_NAME="roastmylanding-frontend-${{ github.sha }}"
          
          if ! aws s3 ls "s3://$BUCKET_NAME" 2>/dev/null; then
            aws s3 mb "s3://$BUCKET_NAME"
            
            # Configure bucket for static website hosting
            aws s3 website "s3://$BUCKET_NAME" --index-document index.html --error-document error.html
            
            # Set bucket policy for public read
            cat > bucket-policy.json << EOF
          {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Sid": "PublicReadGetObject",
                "Effect": "Allow",
                "Principal": "*",
                "Action": "s3:GetObject",
                "Resource": "arn:aws:s3:::$BUCKET_NAME/*"
              }
            ]
          }
          EOF
            aws s3api put-bucket-policy --bucket $BUCKET_NAME --policy file://bucket-policy.json
          fi
          
          echo "FRONTEND_BUCKET=$BUCKET_NAME" >> $GITHUB_ENV
          
      - name: Deploy to S3
        run: |
          aws s3 sync .next/static/ "s3://${{ env.FRONTEND_BUCKET }}/_next/static/" --delete
          aws s3 sync out/ "s3://${{ env.FRONTEND_BUCKET }}/" --delete
          
      - name: Create CloudFront distribution (if not exists)
        run: |
          # Check if distribution exists
          DIST_ID=$(aws cloudfront list-distributions --query "DistributionList.Items[?Origins.Items[0].DomainName=='${{ env.FRONTEND_BUCKET }}.s3-website-${{ env.AWS_REGION }}.amazonaws.com'].Id" --output text)
          
          if [ "$DIST_ID" = "" ] || [ "$DIST_ID" = "None" ]; then
            echo "Creating CloudFront distribution..."
            cat > distribution-config.json << EOF
          {
            "CallerReference": "${{ github.sha }}",
            "Comment": "RoastMyLanding Frontend Distribution",
            "Origins": {
              "Quantity": 1,
              "Items": [{
                "Id": "S3-${{ env.FRONTEND_BUCKET }}",
                "DomainName": "${{ env.FRONTEND_BUCKET }}.s3-website-${{ env.AWS_REGION }}.amazonaws.com",
                "CustomOriginConfig": {
                  "HTTPPort": 80,
                  "HTTPSPort": 443,
                  "OriginProtocolPolicy": "http-only"
                }
              }]
            },
            "DefaultCacheBehavior": {
              "TargetOriginId": "S3-${{ env.FRONTEND_BUCKET }}",
              "ViewerProtocolPolicy": "redirect-to-https",
              "MinTTL": 0,
              "DefaultTTL": 86400,
              "MaxTTL": 31536000,
              "ForwardedValues": {
                "QueryString": false,
                "Cookies": {"Forward": "none"}
              }
            },
            "Enabled": true,
            "PriceClass": "PriceClass_100"
          }
          EOF
            DIST_ID=$(aws cloudfront create-distribution --distribution-config file://distribution-config.json --query 'Distribution.Id' --output text)
          fi
          
          echo "Distribution ID: $DIST_ID"
          
          # Invalidate cache
          aws cloudfront create-invalidation --distribution-id $DIST_ID --paths "/*"

  smoke-tests:
    name: Smoke Tests
    runs-on: ubuntu-latest
    needs: [deploy-lambda, deploy-ec2, deploy-frontend]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Run smoke tests
        run: npm run test:smoke
        env:
          API_URL: ${{ secrets.API_GATEWAY_URL }}
          
      - name: Health check
        run: |
          # Check API Gateway health
          curl -f "${{ secrets.API_GATEWAY_URL }}/health" || exit 1
          
          # Check Lambda function
          aws lambda invoke \
            --function-name roastmylanding-roast-handler \
            --payload '{"httpMethod":"GET","path":"/health"}' \
            --region ${{ env.AWS_REGION }} \
            response.json
          
          cat response.json

  notify:
    name: Notify
    runs-on: ubuntu-latest
    needs: [smoke-tests]
    if: always() && github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
      - name: Notify success
        if: needs.smoke-tests.result == 'success'
        run: |
          echo "✅ Deployment successful!"
          # Add Slack/Discord notification here
          
      - name: Notify failure
        if: needs.smoke-tests.result == 'failure'
        run: |
          echo "❌ Deployment failed!"
          # Add Slack/Discord notification here