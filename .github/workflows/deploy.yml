name: Deploy to Production

on:
  push:
    branches: [ main, production ]
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: roast-landing

jobs:
  build-and-deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build, tag, and push image to Amazon ECR
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Build the Docker image
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .
        
        # Push images to ECR
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

    - name: Deploy to EC2
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_SSH_PRIVATE_KEY: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
        APP_PATH: ${{ secrets.EC2_APP_PATH }}
      run: |
        # Create SSH key file
        echo "$EC2_SSH_PRIVATE_KEY" > private_key.pem
        chmod 600 private_key.pem
        
        # Create deployment script
        cat > deploy_script.sh << 'EOF'
        #!/bin/bash
        set -e
        
        # Navigate to app directory
        cd $APP_PATH
        
        # Login to ECR
        aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin $ECR_REGISTRY
        
        # Pull latest image
        docker pull $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        
        # Create environment file with all secrets
        cat > .env.production << 'ENVEOF'
        # App Configuration
        NEXT_PUBLIC_APP_URL=https://tanta.com.ng
        NODE_ENV=production
        
        # Supabase Configuration
        NEXT_PUBLIC_SUPABASE_URL=${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
        NEXT_PUBLIC_SUPABASE_ANON_KEY=${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}
        SUPABASE_SERVICE_ROLE_KEY=${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
        
        # Redis Configuration
        REDIS_HOST=${{ secrets.REDIS_HOST }}
        REDIS_PORT=${{ secrets.REDIS_PORT }}
        REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
        REDIS_DB=${{ secrets.REDIS_DB }}
        REDIS_URL=${{ secrets.REDIS_URL }}
        
        # AI Providers
        OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
        ANTHROPIC_API_KEY=${{ secrets.ANTHROPIC_API_KEY }}
        GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }}
        
        # Stripe
        NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=${{ secrets.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY }}
        STRIPE_SECRET_KEY=${{ secrets.STRIPE_SECRET_KEY }}
        STRIPE_WEBHOOK_SECRET=${{ secrets.STRIPE_WEBHOOK_SECRET }}
        
        # AWS
        AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_REGION=us-east-1
        
        # Storage
        S3_BUCKET=${{ secrets.S3_BUCKET }}
        CLOUDFRONT_DOMAIN=${{ secrets.CLOUDFRONT_DOMAIN }}
        CLOUDFRONT_DISTRIBUTION_ID=${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}
        
        # Google OAuth
        GOOGLE_OAUTH_CLIENT_ID=${{ secrets.GOOGLE_OAUTH_CLIENT_ID }}
        GOOGLE_OAUTH_CLIENT_SECRET=${{ secrets.GOOGLE_OAUTH_CLIENT_SECRET }}
        
        # Notifications
        SLACK_WEBHOOK_URL=${{ secrets.SLACK_WEBHOOK_URL }}
        
        # Cache
        CACHE_BACKEND=redis
        ENVEOF
        
        # Create docker-compose.prod.yml
        cat > docker-compose.prod.yml << 'COMPOSEEOF'
        version: '3.8'
        
        services:
          app:
            image: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
            container_name: roast-landing-app
            restart: unless-stopped
            ports:
              - "3000:3000"
            env_file:
              - .env.production
            healthcheck:
              test: ["CMD", "curl", "-f", "http://localhost:3000/api/health"]
              interval: 30s
              timeout: 10s
              retries: 3
              start_period: 40s
            logging:
              driver: "json-file"
              options:
                max-size: "10m"
                max-file: "3"
        COMPOSEEOF
        
        # Stop existing containers
        docker-compose -f docker-compose.prod.yml down || true
        
        # Start new containers
        docker-compose -f docker-compose.prod.yml up -d
        
        # Wait for health check
        echo "Waiting for application to be healthy..."
        sleep 30
        
        # Health check
        if curl -f http://localhost:3000/api/health; then
          echo "âœ… Application deployment successful!"
        else
          echo "âŒ Application health check failed!"
          docker-compose -f docker-compose.prod.yml logs
          exit 1
        fi
        
        # Cleanup old images (keep last 3)
        docker images $ECR_REGISTRY/$ECR_REPOSITORY --format "table {{.Tag}}\t{{.ID}}" | grep -v TAG | tail -n +4 | awk '{print $2}' | xargs -r docker rmi || true
        
        EOF
        
        # Copy and execute deployment script on EC2
        scp -i private_key.pem -o StrictHostKeyChecking=no deploy_script.sh ubuntu@$EC2_HOST:/tmp/
        ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@$EC2_HOST "
          export ECR_REGISTRY=$ECR_REGISTRY
          export ECR_REPOSITORY=$ECR_REPOSITORY
          export IMAGE_TAG=$IMAGE_TAG
          export APP_PATH=$APP_PATH
          chmod +x /tmp/deploy_script.sh
          /tmp/deploy_script.sh
        "

    - name: Notify Slack on Success
      if: success()
      run: |
        curl -X POST -H 'Content-type: application/json' \
        --data '{
          "text": "ðŸš€ Roast Landing deployment successful!",
          "blocks": [
            {
              "type": "section",
              "text": {
                "type": "mrkdwn",
                "text": "*Roast Landing Production Deployment* âœ…\n\n*Commit:* `${{ github.sha }}`\n*Author:* ${{ github.actor }}\n*Branch:* `${{ github.ref_name }}`\n*Time:* $(date)\n\nðŸŒ *Live at:* https://tanta.com.ng"
              }
            }
          ]
        }' \
        ${{ secrets.SLACK_WEBHOOK_URL }}

    - name: Notify Slack on Failure
      if: failure()
      run: |
        curl -X POST -H 'Content-type: application/json' \
        --data '{
          "text": "âŒ Roast Landing deployment failed!",
          "blocks": [
            {
              "type": "section",
              "text": {
                "type": "mrkdwn",
                "text": "*Roast Landing Production Deployment* âŒ\n\n*Commit:* `${{ github.sha }}`\n*Author:* ${{ github.actor }}\n*Branch:* `${{ github.ref_name }}`\n*Time:* $(date)\n\n Please check the logs for details."
              }
            }
          ]
        }' \
        ${{ secrets.SLACK_WEBHOOK_URL }}